# angr是什么

angr是一个多架构的二进制分析平台，具备对二进制文件的动态符号执行能力（例如Mayhem，KLEE等）和多种静态分析能力。

大概看来，要做到这些必须要克服一些问题：

- 装载二进制文件到到分析平台
- 转换二进制文件为中间描述（intermediate representation）（IR）
- 转换IR为语义描述（即它做什么而不是它是什么）
- 执行真正的分析，这包括：
  - 部分或者全部的静态分析（即依赖分析，程序分片）
  - 对程序状态空间的符号探索（比如“我们能否一直执行它直到我们找到了一个溢出？”）
  - 对上述的情况的一些混合（比如“让我们执行一部分可导致内存写的内存切片，来发现一个溢出”）

angr拥有的组件能满足所有这些挑战。
这本书将会向你解释每一个组件是如何工作的，以及如何使用它们来完成你的邪恶目标（原文：accomplish your evil goals）。

# 装载二进制程序

angr安装完成后，你就可以装载二进制程序进行分析了。这个过程以及支持它的angr组件CLE的详细描述在[这里](./loading.md)。

# 中间代表（Intermediate Representation）

angr使用中间描述（具体来说，VEX）在不同的架构上分析二进制文件。关于IR的详细说明在[这里](./ir.md)。

# 求解引擎（Solver Engine）

angr的子模块Claripy解决约束求解和一些其它计算性的需求。大多数的angr使用者不需要知道Claripy的任何事，但我们仍然提供文档以防万一。其详细说明可以看[这里](./claripy.md)。

# 程序状态（Program States）

angr提供模拟的程序状态的接口。理解它是成功使用angr的关键。详细说明可以看[这里](./states.md)。

# 程序路径（Program Paths）

程序可以通过其所有可能的执行路径来分析。angr会揭露关于路径如何被执行的信息。[这一节](./paths.md)给出了如何使用angr这一能力的总览。

# 语义表达（Semantic Representation）

angr的一个强大的能力就是通过基本块对于程序状态的影响来描述它们。换句话说，angr可以推断出基本块做什么，而不仅仅是它们是什么。这通过SimuVEX模块来完成，详细描述可以看[这里](./simuvex.md)。

# 符号执行（Symbolic Execution）

angr提供了强大的符号执行引擎。这个引擎的接口以及使用方法在[这里](./surveyors.md)。

# 完整的程序分析

上面描述的所有模块组合起来使得angr可以进行复杂的、完全的程序分析。关于进行和记录分析的机制的详细说明可以看[这里](./analyses.md)。

# 例子

我们准备了一些使用angr的例子！你可以在[这里](./examples.md)找到它们。